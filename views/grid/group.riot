<grid-group>
  <div class={ classes({ 'dashup-grid-group' : true, 'mb-5' : props.group && props.group.value }) }>

    <!-- GROUP LABEL -->
    <div class="group-title" if={ props.group && props.group.label }>
      { props.group.label }
    </div>
    <!-- / GROUP LABEL -->

    <!-- GRID -->
    <div class="grid-main">
      <div class="grid-scroll">

        <!-- GRID HEADER -->
        <div class="grid-header" if={ !loading('columns') }>

          <div class="grid-column grid-column-add">
            <div class="column-inner">
              <div if={ props.dashup.can(props.page, 'submit') && !props.isSelected } class="column-body">
                <div class="form-check">
                  <input class="form-check-input" type="checkbox" value="selected" onchange={ (e) => onSelectAll(e) } />
                </div>
              </div>
            </div>
          </div>

          <!-- ACTUAL COLUMNS -->
          <div class="grid-column-scroll">
            <div each={ (column, i) in getColumns() } class={ classes({ 'grid-column grid-column-header' : true, 'active' : column.id === state.renaming }) } data-column={ i } style={ `flex-basis:${column.basis}%;max-width:${column.basis}%` }>
              <div class="column-inner">
                <div class="column-body">
                  <div if={ column.id !== state.renaming } class={ classes({ 'column-body-inner' : true, 'moves' : props.dashup.can(props.page, 'alter') }) }>
                    { column.title }
                  </div>
                  <input if={ column.id === state.renaming } class="column-body-inner" value={ column.title } onkeyup={ (e) => onKeyupRenameColumn(e, column) } />
                </div>
                <button class={ classes({ 'btn btn-sm btn-light column-btn ml-2 mr-0' : true, 'active' : isSorted(column) }) } onclick={ (e) => onSort(e, column) }>
                  <i class="fa fa-arrows-v" if={ !isSorted(column) } />
                  <i class="fa fa-arrow-up" if={ props.page.get('data.sort.way') === -1 && isSorted(column) } />
                  <i class="fa fa-arrow-down" if={ props.page.get('data.sort.way') === 1 && isSorted(column) } />
                </button>

                <div class="btn-group dropdown ml-0 mr-0" if={ column.id === state.renaming }>
                  <button class="btn btn-sm btn-light column-btn" onclick={ (e) => onCompleteRenameColumn(e, column) }>
                    <i class="fa fa-check" />
                  </button>
                  <button class="btn btn-sm btn-light column-btn" onclick={ (e) => onRenameColumn(e, null) }>
                    <i class="fa fa-times" />
                  </button>
                </div>
                <div if={ props.dashup.can(props.page, 'alter') } class="btn-group dropdown ml-0 mr-0" if={ column.id !== state.renaming }>
                  <button class="btn btn-sm btn-light column-btn dropdown-toggle" type="button" id={ `grid-column-${i}` } data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                    <i class="fa fa-cog" />
                  </button>

                  <div class="dropdown-menu dropdown-menu-right" aria-labelledby={ `grid-column-${i}` }>
                    <a class="dropdown-item" href="#!" onclick={ (e) => onRenameColumn(e, column) }>Rename Column</a>
                    <a class="dropdown-item" href="#!" onclick={ (e) => onRemoveColumn(e, column) }>Remove Column</a>
                    <a if={ column.field === 'custom' } class="dropdown-item" href="#!" onclick={ (e) => onUpdateColumn(e, column) }>Update Column</a>
                  </div>
                </div>

                <div class="column-resize" if={ props.dashup.can(props.page, 'alter') } />
              </div>
            </div>
          </div>
          <!-- / ACTUAL COLUMNS -->

          <!-- ADD COLUMN -->
          <div class="grid-column grid-column-add">
            <div class="column-inner">
              <div class="column-body" if={ !props.dashup.can(props.page, 'alter') }>
                <button class="btn btn-sm btn-outline-secondary" type="button">
                  <i class="fa fa-columns" />
                </button>
              </div>
              <div class="column-body dropdown" if={ props.dashup.can(props.page, 'alter') }>
                <button class="btn btn-sm btn-outline-primary dropdown-toggle" type="button" id="grid-column-add" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                  <i class="fa fa-columns" />
                </button>
                <div class="dropdown-menu dropdown-menu-right p-0" aria-labelledby="grid-column-add">
                  <div class="card p-2">
                    <nav class="nav flex-column">
                      <a href="#!" class="nav-link disabled">
                        <b>Add Column</b>
                      </a>
                      <a each={ (column, i) in props.fields } href="#!" class="nav-link" onclick={ (e) => onAddColumn(e, column) }>
                        { column.label }
                      </a>
                      <hr />
                      <a href="#!" class="nav-link" onclick={ (e) => onAddCustom(e) }>
                        <i class="fa fa-function mr-2" />
                        Custom
                      </a>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <!-- / ADD COLUMN -->

        </div>
        <!-- / GRID HEADER -->

        <!-- GRID BODY -->
        <grid-body ref={ ref('body') } items={ state.items } forms={ getForms() } on-select={ (item, way) => onSelect(item, way) } selected={ state.selected } sort={ state.sort } loading={ loading } { ...getProps() } />
        <!-- / GRID BODY -->

        <!-- BULK ACTION -->
        <div if={ props.dashup.can(props.page, 'submit') && getSelected() }>
          <div class="mt-3 mb-2">
            <b>{ getSelected().toLocaleString() } Items Selected</b>
          </div>
          <div class="grid-body">
            <div class="grid-row">
              <div class="grid-column grid-column-add">
                <div class="column-inner align-items-center justify-content-center">
                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" value="selected" checked onclick={ (e) => onClearSelect(e) } />
                  </div>
                </div>
              </div>

              <div class="grid-column-scroll">
                <div each={ (column, i) in getAvailableColumns() } class={ classes({ 'grid-field' : true, 'active' : false }) } style={ `flex-basis:${column.basis}%;max-width:${column.basis}%` }>
                  <grid-column if={ column.field !== 'custom' } i={ i } class="field-inner" column={ column } item={ empty } on-edit={ (e, i, el) => props.onEdit(e, i, el, getBulk()) } { ...getProps(true) } />
                </div>
              </div>

              <div class="grid-column grid-column-edit">
                <div class="column-inner align-items-center justify-content-center">
                  <div class="column-body">
                    <button class="btn btn-sm btn-outline-danger" onclick={ (e) => onRemoveItems(e) }>
                      <i class="fa fa-trash" />
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <!-- / BULK ACTION -->
      </div>

      <!-- PAGINATION -->
      <div class="px-2 pt-3 mb-5" if={ !props.noPagination }>
        <div class="row">
          <div class="col-sm-6 d-flex align-items-center">
            <div class="pagination-stats text-muted w-100">
              Showing { ((state.page - 1) * getLimit()) + 1 } - { (state.page * getLimit()) > state.count ? state.count : (state.page * getLimit()) } of { state.count }
            </div>
          </div>
          <div class="col-sm-6 d-flex align-items-center">
            <div class="w-100">
              <div class="btn-group float-sm-right">
                <button class={ classes({ 'btn btn-sm btn-outline-primary' : true, 'disabled' : !hasPrev() }) } aria-label="First" onclick={ (e) => onFirst(e) }>
                  <i class="fa fa-chevron-double-left" />
                </button>
                <button class={ classes({ 'btn btn-sm btn-outline-primary' : true, 'disabled' : !hasPrev() }) } aria-label="Previous" onclick={ (e) => onPrev(e) }>
                  <i class="fa fa-chevron-left" />
                </button>
                <button each={ (p, i) in getPages() } class={ classes({ 'btn btn-sm btn-outline-primary' : true, 'active' : state.page === p }) } data-page={ p } onclick={ (e) => onPage(e, p) }>
                  { p }
                </button>
                <button class={ classes({ 'btn btn-sm btn-outline-primary' : true, 'disabled' : !hasNext() }) } aria-label="Next" onclick={ (e) => onNext(e) }>
                  <i class="fa fa-chevron-right" />
                </button>
                <button class={ classes({ 'btn btn-sm btn-outline-primary' : true, 'disabled' : !hasNext() }) } aria-label="Last" onclick={ (e) => onLast(e) }>
                  <i class="fa fa-chevron-double-right" />
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- / PAGINATION -->

    </div>
    <!-- / GRID -->
    
    <div if={ state.removing } class="modal fade" id="column-remove">
      <div class="modal-dialog">
        <div class="modal-content">

          <!-- Modal Header -->
          <div class="modal-header">
            <h5 class="modal-title">
              Removing <b>{ state.removing.title }</b>
            </h5>
            <button type="button" class="btn-close" data-dismiss="modal">&times;</button>
          </div>

          <!-- Modal body -->
          <div class="modal-body">
            Are you sure you want to remove this item?
          </div>

          <!-- Modal footer -->
          <div class="modal-footer">
            <button type="button" class="btn btn-info mr-auto" data-dismiss="modal">
              Close
            </button>
            <button type="button" class="btn btn-danger" onclick={ (e) => onCompleteRemoveColumn(e, state.removing) }>
              Confirm
            </button>
          </div>

        </div>
      </div>
    </div>

    <div if={ getSelected() } class="modal fade" id="selected-remove">
      <div class="modal-dialog">
        <div class="modal-content">

          <!-- Modal Header -->
          <div class="modal-header">
            <h5 class="modal-title">
              Removing <b>{ getSelected().toLocaleString() } items</b>
            </h5>
            <button type="button" class="btn-close" data-dismiss="modal">&times;</button>
          </div>

          <!-- Modal body -->
          <div class="modal-body">
            Are you sure you want to remove these items?
          </div>

          <!-- Modal footer -->
          <div class="modal-footer">
            <button type="button" class="btn btn-info mr-auto" data-dismiss="modal">
              Close
            </button>
            <button type="button" class={ classes({ 'btn btn-danger' : true, 'disabled' : loading('item.remove') }) } disabled={ loading('item.remove') } onclick={ (e) => onCompleteRemoveItems(e) }>
              { loading('item.remove') ? 'Loading...' : 'Confirm' }
            </button>
          </div>

        </div>
      </div>
    </div>
    
    <div if={ state.updating } class="modal fade" id="column-update">
      <div class="modal-dialog">
        <div class="modal-content">

          <!-- Modal Header -->
          <div class="modal-header">
            <h5 class="modal-title">
              Updating <b>{ state.updating.title }</b>
            </h5>
            <button type="button" class="btn-close" data-dismiss="modal">&times;</button>
          </div>

          <!-- Modal body -->
          <div class="modal-body">
            <div class="mb-3">
              <label class="form-label">
                Column Title
              </label>
              <input class="form-control" ref={ ref('title') } value={ state.updating.title } onchange={ (e) => onColumnTitle(e) } />
            </div>
            <div class="mb-3">
              <label class="form-label">
                Column Sort
              </label>
              <input class="form-control" ref={ ref('sort') } value={ state.updating.sort } onchange={ (e) => onColumnSort(e) } />
            </div>
            <div class="mb-3">
              <label class="form-label">
                Column Display
              </label>
              <code-block ref={ ref('display') } mode="handlebars" content={ state.updating.view || '' } prevent-update={ true } on-change={ (e) => onColumnView(e) } />
              <div class="alert alert-primary mt-2">
                <hbs template={ state.updating.view || '' } data={ state.items && state.items[0] ? state.items[0].get() : {} } />
              </div>
            </div>
          </div>

          <!-- Modal footer -->
          <div class="modal-footer">
            <button type="button" class="btn btn-info mr-auto" data-dismiss="modal">
              Close
            </button>
          </div>

        </div>
      </div>
    </div>
  </div>

  <script>
    // require base class
    import { v4 as uuid } from 'uuid';
    import PerfectScrollbar from 'perfect-scrollbar';

    // grid body
    import gridBody from './body';
    import gridColumn from './column';

    // export default
    export default class GridGroup {

      // ////////////////////////////////////////////////////////////////////////////
      //
      // RIOT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * static get components
       */
      static get components() {
        // return grid
        return {
          gridBody,
          gridColumn,
        };
      }

      /**
       * on before mount
       */
      onBeforeMount(...args) {
        // do ref
        if (this.props.ref) this.props.ref(this);

        // bind
        this.init = this.init.bind(this);
        this.empty = new this.props.dashup.Model({}, this.props.dashup);
        this.loading = this.loading.bind(this);

        // bind
        this.onItems = this.onItems.bind(this);
        this.onSelect = this.onSelect.bind(this);
        this.onSelectAll = this.onSelectAll.bind(this);
        this.beginResize = this.beginResize.bind(this);
        this.onItemsEmpty = this.onItemsEmpty.bind(this);
        this.onUpdateColumn = this.onUpdateColumn.bind(this);

        // page/count
        this.state.page = 1;
        this.state.count = 0;

        // listeners
        this.props.page.on('do.sort', this.init);
        this.props.page.on('do.page', this.init);
        this.props.page.on('do.data.model', this.init);
        this.props.page.on('do.data.forms', this.init);
        this.props.page.on('do.data.limit', this.init);
        this.props.page.on('do.user.where', this.init);
        this.props.page.on('do.user.filter', this.init);
        this.props.page.on('do.data.filter', this.init);
        
        // min and max widths
        this.minW = 5;

        // init basis
        this.initBasis();

        // safe update
        this.safeUpdate = () => {
          // update
          this.update();
        };
      }

      /**
       * on mounted
       */
      onMounted(...args) {
        // init
        this.init().then(() => {
          // other inits
          this.initSize();
          this.initSort();
          this.initResize();
        });
      }

      /**
       * on before mount
       */
      onBeforeUnmount(...args) {
        // listeners
        this.props.page.removeListener('do.sort', this.init);
        this.props.page.removeListener('do.page', this.init);
        this.props.page.removeListener('do.data.model', this.init);
        this.props.page.removeListener('do.data.forms', this.init);
        this.props.page.removeListener('do.data.limit', this.init);
        this.props.page.removeListener('do.user.where', this.init);
        this.props.page.removeListener('do.user.filter', this.init);
        this.props.page.removeListener('do.data.filter', this.init);
        
        // items
        if (this.state.items && this.state.items.removeListener) {
          // safe update
          this.state.items.removeListener('update', this.safeUpdate);
          this.state.items.deafen();
        }
      }

      /**
       * on mounted
       */
      onUpdated(...args) {
        // init
        this.initSize();
        this.initSort();
        this.initResize();

        /**
         * search
         */
        if (this.props.search !== this.search) {
          // search
          this.search = this.props.search;

          // do init
          this.init();
        }
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // EVENT METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * on select item
       */
      onSelect(item, way) {
        // on select
        if (this.props.onSelect) return this.props.onSelect(item);

        // check item
        let selected = this.state.selected || {
          type  : 'items',
          items : [],
        };

        // check items
        if (['all', 'except'].includes(selected.type)) {
          selected.type = 'except';
        } else {
          selected.type = 'items';
        }

        // check items
        if (!way && selected.type === 'except') {
          // filter
          if (!selected.items.includes(item.get('_id'))) selected.items.push(item.get('_id'));
        } else if (way && selected.type === 'except') {
          // filter
          selected.items = selected.items.filter((i) => i !== item.get('_id'));

          // check length
          if (!selected.items.length && selected.type === 'except') {
            // type all
            selected.type = 'all';
          }
        } else if (way) {
          // add
          if (!selected.items.includes(item.get('_id'))) selected.items.push(item.get('_id'));
        } else {
          // remove
          selected.items = selected.items.filter((i) => i !== item.get('_id'));
        }

        // set count
        selected.count = this.getSelected(selected);

        // selected update
        this.update({
          selected,
        });
      }

      /**
       * on select all
       */
      onSelectAll(e) {
        // check item
        if ($(e.target).is(':checked')) {
          // set items
          this.update({
            selected : {
              type  : 'all',
              items : [],
              count : this.getSelected({
                type  : 'all',
                items : [],
              }),
            }
          });
        } else {
          this.update({
            selected : null,
          });
          $('.form-check-input:checked', this.root).prop('checked', false);
        }
      }

      /**
       * clear selection
       */
      onClearSelect(e) {
        // prevent
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }

        // clear selected
        this.update({
          selected : null,
        });
        $('.form-check-input:checked', this.root).prop('checked', false);
      }

      /**
       * on rename column
       */
      onRemoveItems(e) {
        // add page
        e.preventDefault();
        e.stopPropagation();
        
        // show modal
        $(this.$('#selected-remove')).modal('show');
      }

      /**
       * on complete remove items
       */
      async onCompleteRemoveItems(e) {
        // loading
        this.loading('item.remove', true);
        
        // do bulk remove
        await this.props.dashup.rpc(this.state.items[0].get('_meta'), 'model.bulk', {
          by    : this.state.selected.type,
          type  : 'remove',
          items : this.state.selected.items,
          query : this.getQuery().query,
        });
        
        // show modal
        $(this.$('#selected-remove')).modal('hide');

        // update grid
        this.props.page.emit('do.page');

        // remove selected
        this.onClearSelect();

        // loading
        this.loading('item.remove', false);
      }

      /**
       * on sort
       */
      async onSort(e, column) {
        // prevent
        e.preventDefault();
        e.stopPropagation();

        // check sort
        let sort = this.props.page.get('data.sort') || {};

        // get field
        const sortField = this.props.fields.find((f) => f.uuid === column.field);

        // check sort
        if (column.sort) {
          if (sort.sort && sort.sort === column.sort) {
            if (sort.way === -1) {
              sort.way = 1;
            } else {
              sort = null;
            }
          } else {
            sort.way  = -1;
            sort.sort = column.sort;
          }
        } else {
          if (sort.id && sort.id === column.field) {
            if (sort.way === -1) {
              sort.way = 1;
            } else {
              sort = null;
            }
          } else {
            sort.id  = column.field;
            sort.way = -1;
          }
        }
        
        // set model
        await this.props.data('sort', sort);
        this.props.page.emit('do.sort');
      }

      /**
       * on add column
       */
      async onAddColumn(e, column) {
        // prevent
        e.preventDefault();
        e.stopPropagation();

        // get page
        const columns = this.getAvailableColumns();

        // push column
        columns.push({
          id    : uuid(),
          title : column.label,
          field : column.uuid,
          order : columns.length + 1
        });
        this.initBasis(columns);
        
        // set model
        await this.saveColumns(columns);
      }

      /**
       * on add custom
       */
      async onAddCustom(e) {
        // prevent
        e.preventDefault();
        e.stopPropagation();

        // get page
        const columns = this.getAvailableColumns();
        const column = {
          id    : uuid(),
          title : 'Custom Label',
          field : 'custom',
          order : columns.length + 1
        };

        // push column
        columns.push(column);
        this.initBasis(columns);
        
        // set model
        await this.saveColumns(columns);

        // on column view
        this.onUpdateColumn(e, column);
      }

      /**
       * on column view
       */
      onColumnView(val) {
        // set val
        const columns = this.getAvailableColumns();

        // get column
        const column = columns.find((c) => c.id === this.state.updating.id);

        // set view
        column.view = val;
        this.state.updating.view = val;

        // update
        this.saveColumns(columns);
      }

      /**
       * on column view
       */
      onColumnTitle(e) {
        // set val
        const columns = this.getAvailableColumns();

        // get column
        const column = columns.find((c) => c.id === this.state.updating.id);

        // set view
        column.title = e.target.value;
        this.state.updating.title = e.target.value;

        // update
        this.saveColumns(columns);
      }

      /**
       * on column sort
       */
      onColumnSort(e) {
        // set val
        const columns = this.getAvailableColumns();

        // get column
        const column = columns.find((c) => c.id === this.state.updating.id);

        // set view
        column.sort = e.target.value;
        this.state.updating.sort = e.target.value;

        // update
        this.saveColumns(columns);
      }

      /**
       * on rename column
       */
      onRenameColumn(e, column) {
        // add page
        e.preventDefault();
        e.stopPropagation();

        // set page
        this.update({
          renaming : column ? column.id : null,
        });

        // timeout
        setTimeout(() => {
          // focus
          if ($('.grid-header input')) $('.grid-header input').focus();
        }, 10);
      }

      /**
       * on enter pressed
       */
      onKeyupRenameColumn(e, column) {
        // check which
        if (e.which !== 13) return true;
        
        // rename
        return this.onCompleteRenameColumn(e, column);
      }
      
      /**
       * on complete remove column
       */
      onCompleteRenameColumn(e, column) {
        // add page
        e.preventDefault();
        e.stopPropagation();

        // set value
        column.title = $('.grid-header input.column-body-inner').val();

        // remove
        this.update({
          renaming : null,
        });

        // on data
        this.saveColumns(this.getAvailableColumns());
      }

      /**
       * on remove column
       */
      onRemoveColumn(e, column) {
        // add page
        e.preventDefault();
        e.stopPropagation();

        // close
        if (this.closePopped) this.closePopped();

        // set page
        this.update({
          removing : column,
        });

        // show modal
        $(this.$('#column-remove')).modal('show');
        $(this.$('#column-remove')).one('hidden.bs.modal', () => {
          // reset hunting
          this.update({
            removing : null,
          });
        });
      }

      /**
       * on update column
       */
      onUpdateColumn(e, column) {
        // add page
        e.preventDefault();
        e.stopPropagation();

        // close
        if (this.closePopped) this.closePopped();

        // set page
        this.update({
          updating : column,
        });

        // show modal
        $(this.$('#column-update')).modal('show');
        $(this.$('#column-update')).one('hidden.bs.modal', () => {
          // reset hunting
          this.update({
            updating : null,
          });
        });
      }
      
      /**
       * on complete remove column
       */
      onCompleteRemoveColumn(e, column) {
        // add page
        e.preventDefault();
        e.stopPropagation();

        // remove
        $(this.$('#column-remove')).modal('hide');
        this.update({
          removing : null,
        });

        // get page
        const columns = this.getAvailableColumns().filter((col) => {
          // check column
          return col.id !== column.id;
        });
        this.initBasis(columns);

        // on data
        this.saveColumns(columns);
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // PAGINATION METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * on pagination click function
       *
       * @param  {Event} e
       */
      onPage(e, page) {
        // prevent scrolling to top
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }

        // get page
        this.state.page = page;
        return this.init();
      }

      /**
       * on next click function
       */
      onLast(e) {
        // prevent scrolling to top
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }

        // get page
        this.state.page = Math.floor(this.state.count / this.getLimit()) + 1;
        return this.init();
      }

      /**
       * on previous click function
       */
      onFirst(e) {
        // prevent scrolling to top
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }

        // get page
        this.state.page = 1;
        return this.init();
      }

      /**
       * on next click function
       */
      onNext(e) {
        // prevent scrolling to top
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }

        // get page
        this.state.page = this.hasNext() ? (this.state.page + 1) : this.state.page;
        return this.init();
      }

      /**
       * on previous click function
       */
      onPrev(e) {
        // prevent scrolling to top
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }

        // get page
        this.state.page = this.hasPrev() ? (this.state.page - 1) : 1;
        return this.init();
      }

      /**
       * on items
       */
      onItems(items, count) {
        // check items
        if (!items) items = this.state.items;
        if (!count) count = this.state.count;

        // page/limit
        const page = this.state.page;
        const limit = this.getLimit();

        // safe update
        this.safeUpdate();

        // on items
        if (this.props.onItems) this.props.onItems(items, count, { page, limit });
      }

      /**
       * on items
       */
      onItemsEmpty() {
        // on items empty
        this.onItems();
      }

      /**
       * get limit
       */
      getLimit () {
        // return limit
        return this.props.page.get('data.limit') || 20;
      }

      /**
       * get pages
       */
      getPages () {
        // reset pages
        const pages = [];

        // set start
        let page = (this.state.page - 5) < 1 ? 1 : (this.state.page - 5);
        let start = ((page - 1) * this.getLimit());
        const main = page;

        // while start less than pages
        while (start < this.state.count) {
          // add to pages
          pages.push(page);

          // add to page
          page += 1;

          // set start value
          start = ((page - 1) * this.getLimit());

          // check if should stop
          if (main - page > 8 || pages.length > 9) {
            break;
          }
        }

        // return pages
        return pages;
      }

      /**
       * Return has previous page
       *
       * @return {boolean}
       */
      hasPrev() {
        // return page greater
        return this.state.page > 1;
      }

      /**
       * Return has next page
       *
       * @return {boolean}
       */
      hasNext() {
        // return page less
        return this.state.page < (Math.floor(this.state.count / this.getLimit()) + 1);
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // Get Methods
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * save columns
       */
      saveColumns(columns) {
        // check column save method
        if (this.props.onColumns) {
          // save via props
          return this.props.onColumns(columns);
        } else {
          // save on page
          return this.props.data('columns', columns);
        }
      }

      /**
       * get columns
       */
      getColumns () {
        // return
        return this.getAvailableColumns().sort((a, b) => {
          // a or b
          const aC = a.order || 0;
          const bC = b.order || 0;

          // check order
          if (bC > aC) return -1;
          if (bC < aC) return 1;
          return 0;
        });
      }

      /**
       * get available columns
       */
      getAvailableColumns() {
        // get columns
        return (this.props.onColumns ? this.props.columns : this.props.page.get('data.columns')) || [];
      }

      /**
       * get selected
       */
      getSelected(selected) {
        // selected
        if (!selected) selected = this.state.selected;

        // check 0
        if (!selected || !selected.type) return 0;

        // selected
        if (selected.type === 'items') {
          return selected.items.length;
        } else if (selected.type === 'all') {
          return this.state.count || 0;
        } else if (selected.type === 'except') {
          return (this.state.count - selected.items.length);
        }
        
        // return 0
        return 0;
      }

      /**
       * get forms
       */
      getForms() {
        // get forms
        if (this.props.page.get('data.forms')) return this.props.page.get('data.forms').filter((f) => f && this.props.dashup.page(f));
        if (this.props.page.get('data.form')) return [this.props.page.get('data.form'), this.props.page.get('data.order.form')].filter((f) => f && this.props.dashup.page(f));
        
        // return any form
        return Array.from(this.props.dashup.get('pages').values()).filter((v) => {
          // return forms
          return v.get('type') === 'form' && v.get('data.model') === (this.props.page.get('data.model') || this.props.page.get('_id'));
        }).map((p) => p.get('_id'));
      }

      /**
       * get bulk
       */
      getBulk() {
        // return
        return { ...(this.state.selected), query : this.getQuery().query };
      }

      /**
       * get props
       */
      getProps(noEdit) {
        // props
        const props = { ...(this.props) };

        // check ref
        delete props.ref;
        delete props.items;

        // delete
        if (noEdit) delete props.onEdit;

        // return props
        return props;
      }

      /**
       * get query
       */
      getQuery() {
        // return query
        if (this.props.query) {
          // get query
          let query = this.props.query();

          // check group
          if (this.props.group && this.props.group.key) {
            // where
            query = query.where({
              [this.props.group.key] : this.props.group.value,
            });
          }

          // return query
          return query;
        };

        // get model
        const model = this.props.model;

        // set query
        let query = this.props.dashup.page(model);

        // forms
        const forms = this.getForms();

        // check items
        if (forms.length) {
          // loop forms
          query = query.in('_meta.form', forms);
        }

        // load filter
        let filter = null;

        // try/catch
        try {
          filter = JSON.parse(this.props.page.get('data.filter'));
        } catch (e) {}

        // add initial where
        if (filter) {
          // add wheres
          filter.forEach((where) => {
            // where
            query = query.where(where);
          });
        }

        // search
        if (this.props.search && this.props.search.length) {
          // add search
          query = query.search(this.props.search);
        }

        // check group
        if (this.props.group && this.props.group.key) {
          // where
          query = query.where({
            [this.props.group.key] : this.props.group.value,
          });
        }

        // test by user
        if ((this.props.page.get('user.filter') || {}).me) {
          // get user fields
          const userFields = [...(this.props.fields || [])].filter((f) => (this.props.page.get('data.user') || []).includes(f.uuid));
          
          // loop fields
          query = query[userFields.length > 1 ? 'or' : 'where'](...(userFields.map((userField) => {
            // return or
            return {
              [userField.name || userField.uuid] : this.props.dashup.get('_meta.member'),
            };
          })));
        }

        // user query
        (this.props.page.get('user.where') || []).forEach((where) => {
          // types
          const numberTypes = ['gt', 'lt', 'gte', 'lte'];

          // add query
          query = query[where[0]](where[1], numberTypes.includes(where[0]) ? parseFloat(where[2]) : where[2]);
        });

        // check vals
        const tagFields = [...(this.props.fields || [])].filter((f) => (this.props.page.get('data.tag') || []).includes(f.uuid));

        // get tags
        const userTags = (this.props.page.get('user.filter.tags') || []).filter((id) => {
          // return find
          return tagFields.find((t) => {
            // check id
            return (t.options || []).find((o) => o.value === id);
          });
        });

        // get filter tags
        if (userTags.length) {
          // loop fields
          query = query[tagFields.length > 1 ? 'or' : 'where'](...(tagFields.map((tagField) => {
            // return or
            return {
              [tagField.name || tagField.uuid] : userTags,
            };
          })));
        }

        // check sort
        if (this.props.page.get('data.sort.id')) {
          // get field
          const sortField = this.props.page.get('data.sort.sort') ? {
            name : this.props.page.get('data.sort.sort'),
          } : this.props.fields.find((f) => f.uuid === this.props.page.get('data.sort.id'));

          // sort by that
          if (sortField) query = query.sort(sortField.name || sortField.uuid, this.props.page.get('data.sort.way'));
        }

        // return query
        return query;
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // Init Methods
      //
      // ////////////////////////////////////////////////////////////////////////////
      
      /**
       * init
       */
      async init () {
        // get model
        let items = [];
        let count = null;
        
        // items
        if (this.state.items && this.state.items.removeListener) {
          // safe update
          this.state.items.removeListener('update', this.onItemsEmpty);
          this.state.items.deafen();
        }

        // get model
        const model = this.props.model;

        // loading
        this.loading('grid', true);

        // query by
        if (model) {
          // get query
          const query = this.getQuery();
          const countQ = this.getQuery();

          // limit
          query.skip(((this.state.page || 1) - 1) * this.getLimit());
          query.limit(this.getLimit());

          // listen
          items = await query.listen();
          count = await countQ.count();

          // listen
          items.on('update', this.onItemsEmpty);
          this.onItems(items, count);
        }

        // update
        this.update({
          items,
          count
        });

        // loading
        this.loading('grid', false);
      }

      /**
       * check sorted
       */
      isSorted(column) {
        // check sort
        if (this.props.page.get('data.sort.sort')) {
          return this.props.page.get('data.sort.sort') === column.sort;
        }
        if (this.props.page.get('data.sort.id')) {
          return this.props.page.get('data.sort.id') === column.field;
        }

        // false
        return false;
      }

      /**
       * init size
       */
      initSize () {
        // min size
        const minSize = (this.getColumns().length * 10);

        // init size
        $(this.$$('.grid-header, .grid-body')).css('min-width', `${minSize}rem`);
      }

      /**
       * init sort
       */
      initSort () {
        // require sort
        const Sortable = require('sortablejs');

        // sortables
        if (this.sortables) {
          // destroy
          try {
            // remove
            this.sortables.forEach((sortable) => sortable.destroy());
          } catch (e) {}
        }

        // sortables
        this.sortables = [];

        // check init
        if (!this.$$('.grid-header').length) return;

        // create sortables
        this.$$('.grid-header .grid-column-scroll').forEach((item) => {
          // push
          this.sortables.push(new Sortable(item, {
            group          : 'grid-group',
            handle         : '.column-body-inner.moves',
            animation      : 200,
            fallbackOnBody : true,

            onEnd : async (e) => {
              // columns
              const columns = this.getAvailableColumns();

              // update columns
              this.$$('.grid-header .grid-column-scroll > .grid-column').forEach((item, i) => {
                // column
                if (!item.getAttribute('data-column')) return;

                // get col
                const col = columns[item.getAttribute('data-column') || 0];

                // col
                col.order = i;
              });

              // loading columns
              this.loading('columns', true);

              // save columns
              this.saveColumns(columns);

              // timeout
              setTimeout(() => {
                // loading columns
                this.loading('columns', false);
              }, 10);
            }
          }));
        });
      }

      /**
       * init resize
       */
      initBasis(columns) {
        // set columns
        if (!columns) columns = this.getAvailableColumns();

        // min width
        const maxW = 100 - ((this.getAvailableColumns().length - 1) * this.minW);

        // check columns
        columns.forEach((col) => {
          // set basis
          if (!col.basis) col.basis = parseFloat((100 / columns.length).toFixed(2));
          if (col.basis < this.minW) col.basis = this.minW;
        });

        // total basis
        const totalBasis = columns.reduce((accum, col) => {
          return accum + col.basis;
        }, 0);

        // fit into basis properly
        if (totalBasis !== 100) {
          // check columns
          columns.forEach((col) => {
            // set basis
            col.basis = parseFloat(((col.basis / totalBasis) * 100).toFixed(2));
          });
        }

      }

      /**
       * init resize
       */
      initResize() {
        // add resize
        $(document).off('mousedown', this.beginResize);
        $(document).on('mousedown', this.beginResize);

        // fix column sizing
        if (this.$('.grid-scroll') && !this.$('.grid-scroll.ps')) {
          // ps
          this.ps = new PerfectScrollbar(this.$('.grid-scroll'));
        }
      }

      /**
       * begin resize
       */
      beginResize(e) {
        // check
        if (!$(e.target).is($(this.$$('.column-resize')))) return;

        // moving
        $(e.target).closest('[data-column]').addClass('column-moving');

        // get attribute
        const i    = parseInt($(e.target).closest('[data-column]').attr('data-column'));
        const col  = this.getAvailableColumns()[i];
        const maxW = 100 - ((this.getAvailableColumns().length - 1) * this.minW);

        // return
        if (!col) return;

        // original values
        const origX = e.pageX;
        const origB = col.basis;

        // set chage
        let change = 0;
        
        // mousemove
        const mousemove = (e) => {
          // update basis
          const newX = e.pageX;

          // width
          const width = $(this.$('.grid-header')).width();

          // update change
          const changeX = origX - newX;

          // check width
          if (!width || !changeX) return;

          // check width of change
          change = (parseFloat(((changeX / width) * 100).toFixed(2)) || 0) * -1;

          // no change
          if (i === (this.getAvailableColumns().length - 1) && change < 0) change = 0;

          // create new basis
          let newB = parseFloat((origB + change > maxW ? maxW : origB + change).toFixed(2));
          if (newB < this.minW) newB = this.minW;

          // current remove
          let currentR = newB - origB;
          let currentI = i + 1;
          let currentP = this.getAvailableColumns()[currentI];

          // remove max evenly from next column in order
          while (currentP && currentR != 0) {
            // remove from next basis
            let nextB = (currentP.basis - currentR) > maxW ? maxW : (currentP.basis - currentR);
            if (nextB < this.minW) nextB = this.minW;

            // set css on other columns
            $(`[data-column="${currentI}"]`).css({
              'max-width'  : `${nextB}%`,
              'flex-basis' : `${nextB}%`
            });

            // remove from current R
            currentR = currentR - (currentP.basis - nextB);
            currentI = currentI + 1;
            currentP = this.getAvailableColumns()[currentI];
          }

          // update basis
          $(`[data-column="${i}"]`).css({
            'max-width'  : `${newB - currentR}%`,
            'flex-basis' : `${newB - currentR}%`,
          });
        };

        // mousemove
        $(document).on('mousemove', mousemove);
        $(document).one('mouseup', (e) => {
          // off
          $(document).off('mousemove', mousemove);

          // create new basis
          let newB = parseFloat((origB + change > maxW ? maxW : origB + change).toFixed(2));
          if (newB < this.minW) newB = this.minW;

          // current remove
          let currentR = newB - origB;
          let currentI = i + 1;
          let currentP = this.getAvailableColumns()[currentI];

          // remove max evenly from next column in order
          while (currentP && currentR != 0) {
            // remove from next basis
            let nextB = (currentP.basis - currentR) > maxW ? maxW : (currentP.basis - currentR);
            if (nextB < this.minW) nextB = this.minW;

            // remove from current R
            currentR = currentR - (currentP.basis - nextB);

            // set basis
            currentP.basis = nextB;

            // next
            currentI = currentI + 1;
            currentP = this.getAvailableColumns()[currentI];
          }

          // set full new basis
          col.basis = newB - currentR;

          // update
          this.saveColumns(this.getAvailableColumns());

          // moving
          $('.column-moving').removeClass('column-moving');
        });
      }


      // ////////////////////////////////////////////////////////////////////////////
      //
      // MISC METHODS
      //
      // ////////////////////////////////////////////////////////////////////////////

      /**
       * ref
       */
      ref(name) {
        // set refs
        if (!this.refs) this.refs = {};

        // return ref function
        return (that) => {
          // set ref
          this.refs[name] = that;
        };
      }

      /**
       * classes
       */
      classes(obj) {
        // return object
        return Object.keys(obj).filter((k) => obj[k]).join(' ');
      }

      /**
       * set loading
       */
      loading(type, way) {
        // set loading
        if (!this.__loading) this.__loading = new Map();

        // check loading
        if (!type) return !!Array.from(this.__loading.values()).find((v) => v);
        if (typeof way === 'undefined') return !!this.__loading.get(type);

        // set loading
        this.__loading.set(type, way);
        this.update();
      }
    }

  </script>
</grid-group>